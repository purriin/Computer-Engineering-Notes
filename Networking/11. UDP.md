## 11.1 Transport Services and Protocols
- Provide *logical communication* between application processes running on different hosts
- Transport protocols actions in end systems:
	- Sender: breaks application messages into *segments*, passes to network layer
	- Receiver: reassembles segments into messages, passes to application layer
- 2 transport protocols available to Internet applications
	- UDP (User Datagram Protocol)
	- TCP (Transport Control Protocol)

**TCP**: Transmission Control Protocol
- Reliable, in-order delivery
- Congestion control
- Flow control
- Connection setup

**UDP**: User Datagram Protocol
- Unreliable, unordered delivery
- No-frills extension of "best-effort" IP

- Services not available:
	- Delay guarantees
	- Bandwidth guarantees

## 11.2 Multiplexing / Demultiplexing

**Multiplexing at Sender**: Handle data from multiple sockets, add transport header (later used for demultiplexing)

**Demultiplexing at Receiver**: Use header info to deliver received segments to correct socket

**How Demultiplexing Works**
- Host receives IP datagrams
	- Each datagram has source IP address, destination IP address
	- Each datagram carries one transport-layer segment
	- Each segment has source, destination port number
- Host uses *IP addresses & part numbers* to direct segment to appropriate socket

**Connectionless Demultiplexing**
- When creating datagram to send into UDP socket must specify
	- Destination IP address
	- Destination port number
- When receiving host receives UDP segment:
	- Checks destination port number in segment
	- Directs UDP segment to socket with that port number
- IP/UDP datagrams with same destination port number but different source IP addresses and/or source port numbers will be directed to same socket at receiving host
- We need Sender port number to provide return address

**Connection-Oriented Demultiplexing**
- TCP socket identified by 4-tuple:
	- Source IP address
	- Source port number
	- Destination IP address
	- Destination port number
- Demux: receiver uses all 4 values (4-tuple) to direct segment to appropriate socket
- Server may support simultaneous TCP sockets:
	- Each socket identified by its own 4 tuple
	- Each socket associated with a different connecting client

- Q: Why does TCP need to work with 4-tuples?
	- Ans: Because the server can have several sockets open for different clients

## 11.3 User Datagram Protocol (UDP)
- "No frills," "bare bones" Internet transport protocol
- "Best effort" service, UDP segments may be: 
	- Lost
	- Delivered out-of-order to app
- Connectionless:
	- No handshaking between UDP sender, receiver
	- Each UDP segment handled independently of others

**Why is there a UDP?**
- No connection establishment (which can add RTT delay)
- Simple: no connection state at sender, receiver
- Small header size
- No congestion control
	- UDP can blast away as fast as desired
	- Can function in the face of congestion

- UDP Use:
	- Streaming multimedia apps (loss tolerant, rate sensitive)
	- DNS
	- SNMP
	- HTTP/3
- If reliable transfer needed over UDP (e.g., HTTP/3)
	- Add needed reliability at application layer
	- Add congestion control at application layer
### 11.3.1 Internet Checksum
**Goal**: Detect errors (i.e., flipped bits) in transmitted segment

**Sender**:
- Treat contents of UDP segment (including UDP header fields and IP addresses) as sequence of 16-bit integers
- Checksum: addition (one's complement sum) of segment content
- Checksum value put into UDP checksum field

**Receiver**:
- Compute checksum of received segment
- Check if computed checksum equals checksum field value:
	- Not equal: error detected
	- Equal: No error but maybe errors nonetheless

**Calculating Checksum**:
- Add all 16-bit integers using 1's-complement arithmetic
- Invert sum and plug in the header field for checksum

- The checksum $b_L$ is calculated as follows:
	- Treating each 16-bit words as an integer, find:
	- $x=b_0 + b_1 + ... + b_{L-1}$ (modulo $2^{16}-1$)
		- Why not modulo $2^{16}$?
	- The checksum is then given by: $b_L = -x\%(2^{16}-1)$ 
	- Thus the headers must satisfy the pattern $0 = b_0 + b_1 +...+b_{L-1} + b_{L} \%(2^{16} - 1)$
	- The checksum calculation is carried out in software using one's complement arithmetic
