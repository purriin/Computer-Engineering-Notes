### 1. CSPR

| 31  |     |     |     |     | 4        0 |
| --- | --- | --- | --- | --- | ---------- |
| N   | Z   | C   | V   | ... | mode       |
### 2. Operator Modes

| Operator Mode    | CPSR  |
| ---------------- | ----- |
| Supervisor (SVC) | 10011 |
| Undefined        | 11011 |
| User             | 10000 |
| Abort            | 10111 |
| IRQ              | 10010 |
| FIQ              | 10001 |

**SVC**: This is the mode used in a 'real computer' for the operating system. There are no restrictions applied to code running in this mode. This is the power-on mode

**User**: This mode is used for application programs. Only certain instructions are permitted, the memory access is constrained.

**Abort**: This mode is entered when an error occurs (E.g. LDR used with a non-word aligned address) (not x of 4)

**IRQ**: This mode is used for interrupt-driven I/O
#### 2.1 Setting Operator Mode
```arm-asm
// Set stack for Abort mode:
LDR SP, =0x40000

// Set stack for SVC mode:
LDR SP, =0x20000

// Note these SP registers are not the same
```
### 3. Exception Handling
- The ARM processor automatically changes modes when an exception occurs:
	1. Processor reset (SVC)
	2. Unimplemented instruction (undefined)
	3. Word-aligned error (ABT mode)
	4. Software interrupt (SVC mode)
	5. Hardware interrupt (IRQ mode)
- When an exception occurs ARM:
	1. Saves CPSR into SPSR of the new mode
	2. Modifies CPSR (bits 4-0) to enter the new mode
	3. Saves PC into LR of the new mode (Note: during execution of the instruction that caused the exception, the PC would already have been incremented by 8)
	4. Loads PC with a unique address associated with the exception (0x10 for ABT mode)
- These unique addresses are in the Exception Vector Table

| Address | Meaning                      |
| ------- | ---------------------------- |
| 0       | Reset exception vector       |
| 4       | Unimplemented instruction    |
| 8       | SVC instruction (to call 00) |
| 0xC     | Abort instruction            |
| 0x10    | Abort Data Read/Write        |
| 0x14    | Unused                       |
| 0x18    | Hardware interupt            |
| 0x1C    |                              |
#### 3.1 Code for Making the Exception Vector Table
```arm-asm
.section .vector, "ax"
B        _start
B        UNIMPLEMENTED_HANDLER
B        OS_CODE
B        INST_ABT_HANDLER
B        ABT_HANDLER
// Any entries that you are not using can be filled with anything (eg. 0)
.word    0 
B        IRQ_HANDLER
.word    0
```
### 4. Hardware Interrupts
- An interrupt is a hardware signal (0 or 1) sent by an I/O device to the ARM processor.
- The interrupt request (IRQ) signal causes ARM to pause execution of the current program and take an IRQ exception (saves CPSR into SPSR for IRQ mode, ... , loads 0x18 into PC)
- When exception handling is finished, the ARM will return to the paused program
```arm-asm
IRQ_HANDLER:   PUSH {R0, R1, R2, R3, ... , LR}
// Code that is needed for handling interrupt
POP {R0, R1, R2, R3, ... , LR}
SUBS PC, LR, #4
```
- When `SUBS` is executed by ARM with PC as the destination register, then this instruction means return from exception.
- So this `SUBS` restores CPSR from SPSR (In this case IRQ mode)
- This restores the CPSR mode bits for the main program (SVC) and the main program's NZCV flags
### 5. Interrupts
**GIC**: A memory-mapped I/O device that receives IRQ requests from all of the "other" I/O devices. The GIC controls the ARM processor's IRQ input. The GIC can be configured by software to enable/disable interrupts from each I/O devices.
- The IRQ_HANDLER is common for all  I/O devices so it must check which I/O device caused it to be called

Interrupt Mask Bit (I): If I = 1 (default), interrupts (IRQ) are masked and not visible to ARM
- Your code has to make I = 0 to enable ARM interrupts (using MSR)
#### 5.1 Steps to Use Interrupts
1. Provide the Exception Vector Table (At least entry 0x18)
2. Initialize the banked SP for IRQ mode
3. Initialize SP for SVC mode
4. Configure GIC to enable interrupts that you are using
5. Enable interrupt generation IRQ for each I/O device
6. Enable interrupts for ARM (I = 0 in CSPR)
7. Provide IRQ_HANDLER, which is branded from 0x18
	1. This code queries the GIC to see which I/O device caused the interrupt
8. Provide the interrupt service routing for each I/O device
9. The IRQ_HANDLER must clear the interrupt form the GIC