- One way to initialize a register with a 32-bit HEX value:
```arm-asm
movw R0, #0x8888
movT R0, #0xAAAA
// R0 = 0xAAAA8888
```
### 1. Other Methods
1. Define a 32-bit value
```arm-asm
.global -start

-start:
MOV R2, #VALUE
LDR R2, [R2]
...

VALUE: .word 0x8888 8888
```
- 2 instructions are used to initialize `R2` because 0x8888 8888 is too large to fit into `#0` in the mov machine code. But VALUE is small enough to fit

2. Pseudo-Addressing Mode called Absolute mode
```arm-asm
.global -start

-start:
LDR: R2, VALUE
LOOP: SUBS R2, #1
	BNE LOOP
END: B END
VALUE: .word 0x8888 8888
```
- When the LDR at address 0 is being executed by ARM it has already automatically incremented PC by 9 (2 words)
- Summary: to implement Absolute mode, ARM uses PC and an offset

3. Pseudo-Addressing Mode Using Data
```arm-asm
.global -start
-start:
		LDR R2, 0x88888888
LOOP: SUBS R2, #1
		BNE LOOP
END:   B END
```
- Best method to use
- Summary: The assembler puts your data 0x88888888 into memory, after your code. This area of memory where data is places is called the **Literal Pool**. In this example the literal pool is at address 0x10
	- The address calculation is the same as before (Abs mode)
	- `[PC, #8]` = 0+8+8 = 0x10
- Important: ARM recommends = Data as the method for register initialization