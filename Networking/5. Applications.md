## 5.1 Application Layer Overview
**Our goals**:
- Conceptual and implementation aspects of application layer protocols
	- Transport-layer service models
	- client-server paradigm
	- peer-to-peer paradigm
### 5.1.1 Some Network Apps
- Social networking
- Web
- Text-messaging

## 5.2 Creating a Network App
- Write programs that:
	- Run on (different) end systems
	- Communicate over network
	- Ex. webserver software communicates with browser software
- No need to write software for network-core devices
	- network core devices do not run user applications
	- Applications on end systems allows for rapid app development, propagation

## 5.3 Application Architecture
- Possible structure of applications
	1. Client-Server
	2. Peer-to-Peer (P2P)
### 5.3.1 Client Server Paradigm
**Server**:
- Always-on-host
- Permanent IP address
- Often in data centres, for scaling

**Clients**:
- Contact, communicate with server
- May be intermittently connected
- May have dynamic IP addresses
- Do *not* communicate directly with each other
- Examples: HTTP, IMAP, FTP
### 5.3.2 Peer-Peer Architecture
- *not* always-on server
- Arbitrary end systems directly communicate
- Peers request service from other peers, provide service in return to other peers
	- Self scalability - new peers bring new service capacity as well as new service demands
- Peers are intermittently connected and change IP addresses
	- Complex management
- Ex. P2P File Sharing

## 5.4 Processes Communicating
**Process**: Program running within a host

- Within same host, 2 processes communicate using inter-process communication (defined by OS)
- Processes in different hosts communicate by exchanging messages

**Client Process**: Process that initiates communication
**Server Process**: Process that waits to be contacted
- Note: applications with P2P architectures have client processes & server processes

## 5.5 Sockets
- Process sends/receives messages to/from its socket
- Socket analogous to door
	- Sending process shoves message out door
	- Sending process relies on transport infrastructure on other side of door to deliver message to socket at receiving process
	- 2 Sockets involved: one on each side

## 5.6 Addressing Processes (IP Address)
- To receive messages, process must have *identifier*
- Host device has unique 32-bit IP address

Q: does IP address of host on which process runs suffice for identifying the process?
A: no, many processes can be running on same host

- Identifier includes both IP address and port numbers associated with process on host
- Example port numbers:
	- HTTP Server: 80
	- Mail Server: 25
	- Port numbers in the range \[0.1023] already assigned to processes
- To send HTTP message to www.ece.utoronto.ca web server: 
	- IP address: 128.100.82.35 
	- port number: 80

**An Application-Layer Protocol Defines**:
1. Types of messages exchanged:
	- Ex. request, response
2. Message Syntax:
	- What fields in messages & how fields are delineated
3. Message Semantics:
	- Meaning of information in fields
4. Rules
	- For when and how processes send & respond to messages
5. Open Protocols:
	- Defined in RFCs, everyone has access to protocol definition
	- Allows for interoperability
	- Ex. HTTP, SMTP
6. Proprietary Protocols:
	- Ex. Skype

**What Transport Service Does an App Need?**
1. Data Integrity
	- Some apps (e.g., file transfer, web transactions) require 100% reliable data transfer
	- other apps (e.g., audio) can tolerate some loss 
2. Timing
	- some apps (e.g., Internet telephony, interactive games) require low delay to be “effective”
3. Throughput
	- some apps (e.g., multimedia) require minimum amount of throughput to be “effective” 
	- other apps (“elastic apps”) make use of whatever throughput they get
4. Security
	- Data integrity, encryption
## 5.7 Internet Transport Protocol Services
**TCP Service Provides**:
1. Reliable transport between sending and receiving process
2. Flow Control: Sender won't overwhelm receiver
3. Congestion Control: Throttle sender when network overloaded
4. Connection-oriented: setup required between client and server processes
**TCP Does Not Provide**: 
1. Timing
2. Minimum throughput guarantee
3. Security

**UDP Service Provides**:
1. Unreliable data transfer between sending and receiving process
**UDP Does Not Provide**: 
1. Reliability
2. Flow control
3. Congestion control
4. Timing
5. Throughput guarantee
6. Security
7. Connection setup
## Securing TCP
**Vanilla TCP & UDP Sockets**:
- No encryption
- Cleartext passwords sent into socket traverse Internet in cleartext

**Transport Layer Security (TLS)**:
- Provides encrypted TCP connections
- Data integrity
- End-point authentication

**TLS implemented in application layer**
- Apps use TLS libraries that use TCP in turn

**TLS Socket API**
- Cleartext sent into socket traverse Internet *encrypted*
