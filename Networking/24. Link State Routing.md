## 24.1 Network-Layer Functions
**Data Plane**
**Forwarding**: Move packets from router's input to appropriate router output

**Control Plane**
**Routing**: Determine route taken by packets from source to destination

- 2 approaches to structuring network control plane:
	1. Per-router control (traditional)
		- Individual routing algorithm components in each and every router interact in the control plane
	2. Logically centralized control (software defined networking)
		- Remote controller computes, installs forwarding tables in routers
## 24.2 Routing Protocols
**Routing Protocol Goal**: Determine "good" paths (equivalently, routes), from sending hosts to receiving host, through network of routers
- Path: sequence of routers packets traverse from given initial source host to final destination host
- "Good": Least "cost", "fastest", "least congested"
- Routing: a "top-10" networking challenge

**Graph Abstraction: Link Costs**
$c_{a,b} = \text{cost of direct link connection a and b}$
- Cost defined by network operator: could always be 1 or inversely related to bandwidth or inversely related to congestion
Graph $G = (N,E)$
$N:$ set of routers = $\{u,v,w,x,y,z\}$
$E:$ set of links = $\{(u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)\}$
## 24.3 Dijkstra's Link-State Routing Algorithm
- See [dijkstra's algorithm](Dijkstra)
- Centralized: Network topology, link costs known to all nodes
	- Accomplished via "link state broadcast"
	- All nodes have same info
- Computes least cost paths from one node ("source") to all other nodes
	- Gives forwarding table for that node
- Iterative: after k iterations, know least cost path to k destinations

**Notation**
$c_{x,y}:$ direct link cost from node $x$ to $y$; $=\infty$ if not direct neighbours

$D(v):$ current estimate of cost of least-cost-path from source to destination $v$

$p(v):$ predecessor node along path from source to $v$

$N':$ set of nodes whose least-cost-path definitely known

#### Dijkstra's Algorithm Pseudocode
```python
Initialization:
	N' = {u} 
	# compute least cost path from u to all other nodes
	for all nodes v
		if v adjacent to u 
		# u initially knows direct-path-cost only to 
			# direct neighbors
			# but may not be minimum cost!
			then D(v)= C_u,v
		else D(v) = âˆž
	Loop
		find w not in N' such that D(w) is a minimum
		add w to N'
		update D(v) for all v adjacent to w and not in N':
			D(v) = min(D(v), D(w) + c_w,v)
		# new least-path-cost to v is either old 
			# least-cost-path to v or known
			# least-cost-path to w plus direct-cost from 
			# w to v
	until all nodes in N'
```

**Notes**: 
- Construct least-cost-path tree by tracing predecessor nodes
- Ties can exist (can be broken arbitrarily)

## 24.4 Reaction to Failure
- If a link fails
	- Router sets link distance to infinity and floods the network with an update packet
	- All routers immediately update their link database and recalculate their shortest paths
	- Recover very quickly
- But watch out for old update messages
	- Add time stamp or sequence number to each update message
	- Check whether each received update message is new
	- If new add it to database and broadcast
	- If older, send update message on arriving link

## 24.5 Dijkstra's Algorithm Discussion
- Algorithm complexity: n nodes
	- Each of n iterations: need to check all nodes, w, not in N
	- n(n+1)/2 comparisons: O($n^2$) complexity
	- more efficient implementations possible: O(nlogn)
- Message complexity:
	- Each router must broadcast its link state information to other n routers
	- Efficient (and interesting) broadcast algorithms O(n) link crossings to disseminate a broadcast message from one source
	- Each router's message crosses O(n) links overall message complexity: O($n^2$)

## 24.6 Dijkstra's Algorithm: Oscillations Possible
- When link costs depend on traffic volume, route oscillations possible