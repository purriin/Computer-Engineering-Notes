- How does ARM know the address in memory of the next instruction to execute
	- **Program Counter (PC)** register always holds the address of the next instruction to be executed
	- PC is register RIS
- Example: Sums a list of data items that are in memory (LIST)
```arm-asm
.global -start
-start: mov R1, #LIST   // register R1 points to the LIST
		LDR R2, [R1]    // R2 <- 5
		ADD R1, #4      // ++ pointer (R1 <- R1 + 4)
		LDR R3, [R1]    // R3 <- 15
		ADD R2, R3      // R2 <- R2 + R3
		ADD R1, #4      // ++ ptr
		LDR R3, [R1]    // R3 <- 25
		ADD R2, R3      // R2 <- R2 + R3
		mov R1, #RESULT // Register R1 points to result
		STR R2, [R1]    // RESULT <- R2 (sum)
END:    B   END
RESULT: .word 0
LIST:   .word 5, 15, 25
```
- Note: `.global` and `.word` are assembler directives
	- They provide information to the assembler

**Terminology**: ARM is load/store architecture which means that only load (LDR) and store (STR) can access memory. All other instructions (mov, ADD, SUB, etc) can access only ARM registers (R0, R1, etc)

- General form of mov:
``` arm-asm
move Rd, operand2
```
- `Rd`: destination register
- `operand2`: a flexible operand that can have several variants. It can be another register `R5` (source register), `#D` (immediate data) or others

- Machine code:

| 31                                                                                                                    | 28       | 25                       | 24         | 21  | 19   | 16                   | 11           |
| --------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------ | ---------- | --- | ---- | -------------------- | ------------ |
| Cond                                                                                                                  | 00       | 1                        | Op code    | 5   | Rn   | Rd                   | operand 2    |
| For ARM, all instructions can execute/not at run time base on condition (The condition "Always" is cond = 1110 ('e')) | always 0 | i bit: 1 for `#D` else 0 | 1101 (mov) |     | 0000 | destination register | `R5` or `#D` |
- Ex. `mov R1, R2`
	- 1110 00 0 1101 0 0000 0001 00 ... 010
- Ex. `mov R3, #5`
	- 1110 00 1 1101 0 0000 0011 00 ... 0101

**Terminology**: LDR also have flexible arguments
- `LDR R2, [R1]` 
	- `R2` <- contents of memory at address in `R1`
- `LDR R2 [R1, #4]`
	- `R2` <- contents of memory at address `R1 + 4`
- `LDR R2 [R1, #4]`
	- `R1` <- `R1 + 4` then `R2` <- new `R1` value
- `LDR R2, [R1], #4`
	- `R2` <- contents `R1, R1` <- `R1 + #4`

- 1-4 are called Addressing Mode
- 1, 2 offset mode
- 3 pre index 
- 4 post index