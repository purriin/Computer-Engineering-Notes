### 1. About C Code
- When you compile C code, the compiler first generates assembly code and then the assembly is run to create machine code
- Start is the beginning of the "common code startup sequence"
	- It initializes SP, initializes any global variables used in main, etc
- Assembly code corresponding to your C code starts at main

- Example Assembly code:
```arm-asm
      LDR R3, =0xFF20 0000
LOOP: LDR R2, [R3, 0x40]
      STR: R2, [R3]
      B LOOP
```
- Example C code:
```c
int main() {
	volatile int* LEDR_ptr = 0xFF20 0000;
	volatile int* SW_ptr = 0xFF20 0040;
	int value;
	while (1) {
		value = *SW_ptr;
		*LEDR_ptr = value;
	}
}
```
- Using `*ptr` is called [pointer dereferencing](Basics%20Of%20C). This is how we read/write specific I/O addresses

**volatile**: Ensures that the pointer variable will always be accessed from its address. Without volatile, the compiler might "move" the reading of `*SW_ptr` outside of the loop in the generated assembly code (since we don't write to `*SW_ptr`) with that optimization, `*SW_ptr` would only be read once and not in a loop
#### 1.1 Brensenham's Algorithm
- Ex. from (1, 1) to (12, 5)
	- $\Delta{x}=11$  
	- $\Delta{y}=4$  
	- ${Error}=-\Delta{x}/2 = -5$
```c
for (x = 1, y = 1; x < 13; ++x) {
	draw_pixel(x,y)
	error = error + delta_y
	if (error >= 0) {
		y = y + 1
		error = error - delta_x
	}
}
```

1. Buffer: The DMA controller sends pixel colors to the VGA starting at the address stored in this register
2. Back Buffer: Your code writes pixel colors for your animations next fram using the base memory address in this register

- Using 2 pixel buffers is called "Double Buffering"
- Key Idea: The DMA is always displaying from the buffer address while your code is always making an image using the Back Buffer address. You can request the DMA to swap the addresses in these registers
- It is useful to know when the DMA is finished sending to VGA the last pixel on the screen
	- This is done by using the S-bit in the status register