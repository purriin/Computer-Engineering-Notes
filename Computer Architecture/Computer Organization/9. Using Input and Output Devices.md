### 1. How to Use Input and Output Devices
- Input and output devices will each have their own addresses
	- We will either want to read or write from them
- Writing:
```arm-asm
// Ex. to a HEX display:
LDR R2, 0xFF20 0020 // Load address of output device
LDR R3, 0x1010101 // Pattern to display
STR R3, [R2] // Write to HEX display
```
- Reading:
	- For example for push buttons: Each data is normally 0 but produces 1 when pressing a KEY
```arm-asm
LDR R2, 0xFF20 0050 // Load address of input device
LDR R0, [R2] // Read KEY data
```

- A timer is an I/O device that can provide an exact delay, by counting down to 0 from a starting load value at a known clock frequency (ex. 200mHz)
### 2. Subroutine Standards
- Code that calls a subroutine (the caller):
	- Pass parameters to subroutine using registers `R0`-`R3`
	- Receive results in `R0`-`R3`
	- If more than 4 parameters/results use the stack
	- Assume that registers `R4-R12` will not be modified by the subroutine
	- Must assume that `R0`-`R3` will be modified by the subroutine
- The subroutine (the callee):
	- Receives parameters `R0`-`R3`
	- Returns results using `R0`-`R3`
	- If more than 4 parameters/results use the stack
	- Cannot modify `R4`-`R12`
	- Can modify `R0`-`R3`
- These rules are known as the ARM procedure call standard (PCS)
- Recall: the stack is an ideal data structure for temporary storage
	- Define stack as 0x2000 (the bottom) and will grow upwards to smaller address space
		- ARM always pushes in the largest to small order pops in opposite order